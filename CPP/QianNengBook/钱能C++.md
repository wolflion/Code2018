## 内容

### Part3 面向对象编程技术

#### chap8 类

+ 8.1、从结构到类
  + 8.1.1 定义结构  [f0801.cpp]
  + 8.1.2 定义类   [f0802.cpp]   *默认private*
  + 知识点
    + `#include<iomanip>`一般是`setfill()`操作。
    + f0801.cpp和f0802.cpp中本质差别是**函数**是属于Date类还是整个应用程序。
    + **成员函数在调用时捆绑了对象，已经含有对象参数了；普通函数调用时不捆绑对象的，所以要传递一个对象参数**。
+ 8.2、成员函数
  + 8.2.1 成员函数定义
  + 8.2.2 使用对象指针  [f0803.cpp]
  + 8.2.3 常成员函数  
  + 8.2.4 重载成员函数  [f0804.cpp]
  + 知识点
    + `class`后面有分号`;`的最主要原因是**与`struct`语法一致**。
    + **只要在类定义中包含的成员函数，就默认为内联函数**，当然具体要编译器看是否能够内联，不是说定义了就一定内联。
    + **指针进行点操作符是非法的**。
    + **设计时**，只是对对象进行读操作，就把成员函数设计为常成员函数。**定义和声明在形式要一致才行**。
    + 【注意】f0804.cpp里`e.set()`时，如果直接传常量值，必须声明时加const，不然的话，只能传入变量。
+ 8.3、操作符
  + 8.3.1 函数重载特征  [f0805.cpp]
  + 8.3.2 性质  *lionel这个能另外记忆*
  + 8.3.3 值返回和引用返回
    + 问题：为什么Point的`+`操作返回Point类的值，而`<<`操作返回流的引用呢？ **`<<`非引用的话，开销太大**。
  + 8.3.4 增量操作符 [f0806.cpp]
    + 前增量
    + 后增量
  + 8.3.5 成员操作符 [f0807.cpp]
  + 知识点
    + **在设计函数时，参数若为类类型，则一般都用引用型；若为内部数据类型，则不用引用型**。
    + **f0805.cpp里声明为friend是为了操作x和y**。
+ 8.4、再论程序结构
  + 8.4.1 访问控制  [f0808.cpp]
  + 8.4.2  类的程序结构  [f0809.cpp]
  + 8.4.3 类作用域  [f0810.cpp]
+ 8.5、屏蔽类的实现
  + 8.5.1 意义    [f0811.cpp]
  + 8.5.2 影响编程方法
  + 8.5.3 影响语言设计
  + 知识点
    + **编程总是先描述一定数据类型之下的实体，再描述其操作**。
+ 8.6、静态成员
  + 8.6.1 静态数据成员 [f0812.cpp] , [f0813.cpp]
  + 8.6.2 静态成员函数 [f0814.cpp]
  + 知识点
    + `int Student::number = 0;  // 静态数据成员在类外分配空间和初始化`
    + **静态成员函数不能访问数据成员**，成员函数的静态性只在第一次声明的时候才是必要的。
+ 8.7、友元
  + 8.7.1 频繁调用问题  [f0815.cpp]
  + 8.7.2 提高访问性能
  + 8.7.3 其它特征
  + 知识点
    + **数据都是引用传递，开销忽略**。矩阵类中不能定义下标操作符`[]`，new操作也不能接受二维的空间申请。
    + **将一个普通函数声明为类的友元，就可以直接访问类的私有数据**。
    + 友元还经常用在操作符重载中，以使操作符有很好的性能。
+ 8.8、目的归纳
+ 8.9、练习8
  + 1、改错 [ex0801.cpp]

#### chap9 对象生灭

+ 9.1、构造函数设计
  + 9.1.1 初始化要求  [f0901.cpp]             *全局和局部对象初始化的区别*
  + 9.1.2 封装性要求
  + 9.1.3 函数形式   *构造函数*
  + 9.1.4 无返回值
  + 9.1.5 set的缺憾 [f0902.cpp]
  + 9.1.6 一次对象
    + `Date(2003,12,23)`没有给出对象名
  + 知识点
    + **创建全局对象，则以全0位的模式表示对象。创建局部对象，则以随机值表示对象**。
    + **直接以类名调用构造函数，产生一个无名对象**
+ 9.2、构造函数的重载
  + 9.2.1 重载构造函数  [f0903.cpp] ，[f0904.cpp]
  + 9.2.2 无参构造函数  
    + 也叫**默认构造函数**
+ 9.3、类成员初始化
  + 9.3.1 默认调用的无参构造函数  [f0905.cpp]
  + 9.3.2 初始化的困惑   [f0906.cpp]
  + 9.3.3 成员的初始化  [f0907.cpp]
  + 知识点
    + **在构造函数体中是不能完成对常量成员和引用成员的初始化**，可以采用构造参数表的方式解决。
+ 9.4、构造顺序
  + 9.4.1 局部对象   [f0908.cpp]
  + 9.4.2 全局对象  [f0909.cpp]，[f090902.cpp]
  + 9.4.3 成员对象  [f0910.cpp]
  + 9.4.4 构造位置
    + 全局数据区
    + 栈区
    + 动态内存区（堆区）
    + 特殊地址空间
+ 9.5、拷贝构造函数
  + 9.5.1 对象本体与实体 [f0911.cpp]
  + 9.5.2 默认拷贝构造函数  [f0912.cpp]
  + 9.5.3 自定义拷贝构造函数 [f0913.cpp]
+ 9.6、析构函数  [f0914.cpp]
  + 知识点
    + **静态对象在程序运行结束之时析构**。
+ 9.7、对象转型与赋值
  + 9.7.1 用于转型的构造函数  [f0915.cpp]， [f0916.cpp]
  + 9.7.2 对象赋值  [f0917.cpp]
+ 9.8、归纳
+ 9.9、练习

#### chap10 继承

+ 10.1、继承结构
  + 10.1.1 类层次结构
  + 10.1.2 派生类对象结构
  + 知识点
    + **问题**：子类如何更改父类的操作，或者屏蔽掉父类的一个操作。
+ 10.2、访问父类成员
  + 10.2.1 继承父类成员  [f1001.cpp]
  + 10.2.2 类内访问控制
  + 知识点
    + **public继承后，基类priviate成员只对基类自己的成员开放。**
    + **继承后，基类protected成员对派生类开放**
+ 10.3、派生类的构造
  + 10.3.1 默认构造
  + 10.3.2 自定义构造  [f1002.cpp]
  + 10.3.3 拷贝构造与赋值
  + 10.3.4 对象构造顺序
  + 知识点
    + **派生类的默认无参构造函数会首先调用父类的无参构造函数，如果父类定义了有参构造函数，而没有重载定义无参构造函数，编译器会报错**。
+ 10.4、继承方式
  + 10.4.1 继承访问控制  [f1003.cpp]
  + 10.4.2 调整访问控制  [f1004.cpp]
+ 10.5、继承与组合
  + 10.5.1 对象结构
  + 10.5.2 性质差异
  + 10.5.3 对象分析  [point.h]，[point.cpp]
  + 10.5.4 继承设计  [circle_inher.cpp] 
  + 10.5.5 组合设计  [circle_compos.cpp],  [f1005.cpp]
  + 知识点
    + **对于组合，成员对象的数据隐私是不能被直接访问的，必须通过成员对象的操作去间接访问**。（类对象和成员对象之间是彼此独立的）

+ 10.6、多继承概念
  + 10.6.1 多继承结构  [f1006.cpp]
  + 10.6.2 基类成员名冲突
  + 10.6.3 基类分解  [f1007.cpp]
+ 10.7、多继承技术
  + 10.7.1 虚拟继承   [f1008.cpp]
  + 10.7.2 多继承对象构造顺序
  + 10.7.3 多继承评价
  + 知识点
    + **基类（不管是虚基，还是非虚）都按照它们被继承的顺序构造**。
    + 成员对象的构造函数按按照声明的顺序构造
    + 类自己的构造函数
+ 10.8、目的归纳
+ 10.9、练习10

#### chap11 基于对象编程

#### chap12 多态

+ 12.1、继承召唤多态
  + 12.1.1 祖孙互易的说明
  + 12.1.2 覆盖父类操作  [f1201.cpp]
  + 12.1.3 同化效应 [f1202.cpp]
  + 12.1.4 渴望多态
  + 知识点
    + **基类对象给子类对象赋值是不行的**，因为基类不含有子类信息。
    + `reinterpret_cast<>`这种转换，**纯粹是地址不变而指针类型改变**。
+ 12.2、抽象编程的困惑
  + 12.2.1 类型域方案  [f1203.cpp]
  + 12.2.2 破坏抽象编程  [f1204.cpp]
  + 12.2.3 渴望内在的多态
+ 12.3、虚函数
  + 12.3.1 多态条件  [f1205.cpp]
  + 12.3.2 虚函数机理
  + 12.3.3 面向对象的真意
  + 12.3.4 虚函数的传播  [f1206.cpp]
  + 知识点
    + **一旦标记基类的函数为虚函数，后面继承的类中一切同名成员函数都变成了虚函数**。
    + **仅仅对于对象的指针和引用的间接访问，才会发生多态现象**。
    + **采用虚函数会影响一些程序运行的效率**，其对象空间比不用虚函数的类多了一个指针的空间。
+ 12.4、避免虚函数误用
  + 12.4.1 搞清重载与覆盖  [f1207.cpp]
  + 12.4.2 返回类型的例外 [f1208.cpp]
  + 12.4.3 若干限制
    + **内联函数不能是虚函数**
  + 知识点
    + **虚函数的话，基类和子类的函数名必须相同外，连参数类型，个数和顺序都要相同**。
+ 12.5、精简共性的类
  + 12.5.1 孤立的类  [f1209.cpp]
  + 12.5.2 减少冗余代码  [f1210.cpp]
  + 12.5.3 改变基类殃及子类
+ 12.6、多态编程
  + 12.6.1 共同基类方案  [f1211.cpp]
  + 12.6.2 自定义链表类
  + 12.6.3 表现多态  [f1212.cpp]
+ 12.7、类型转换
  + 12.7.1 动态转型   [f1213.cpp]
  + 12.7.2 静态转型
  + 12.7.3 常量转型
+ 12.8、目的归纳
+ 12.9、练习12